// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: post.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
)

const getPostsByUserAndTags = `-- name: GetPostsByUserAndTags :one
WITH post_likes AS (
    SELECT p.id, COUNT(ulp.post_id) AS total_likes
    FROM "post" p
             LEFT JOIN "user_liked_post" ulp ON p.id = ulp.post_id
    GROUP BY p.id
),
     filtered_posts AS (
         SELECT p.id, p.title, p.description, p.created_at AS "createdAt", ap.price, p.views,
                pl.total_likes AS "totalLikes",
                json_build_object('userId', u.id,
                                  'username', u.username,
                                  'name', u.name,
                                  'avatar', u.avatar_link) AS "user",
                json_build_object('artworkId', a.id,
                                  'image', a.processed_image_link,
                                  'type', a.type,
                                  'isBuyable', a.is_buyable) AS "artwork",
                EXISTS (
                    SELECT 1
                    FROM "user_liked_post" ulp
                    WHERE ulp.post_id = p.id AND ulp.user_id = NULLIF($5::unknown, '00000000-0000-0000-0000-000000000000')::UUID
                ) AS "isLiked",
                ROW_NUMBER() OVER (ORDER BY
                    CASE WHEN $3::text = 'title' AND $4::text = 'ASC' THEN p.title END,
                    CASE WHEN $3::text = 'title' AND $4::text = 'DESC' THEN p.title END DESC,
                    CASE WHEN $3::text = 'price' AND $4::text = 'ASC' THEN ap.price END,
                    CASE WHEN $3::text = 'price' AND $4::text = 'DESC' THEN ap.price END DESC,
                    CASE WHEN $3::text = 'createdAt' AND $4::text = 'ASC' THEN p.created_at END,
                    CASE WHEN $3::text = 'createdAt' AND $4::text = 'DESC' THEN p.created_at END DESC,
                    CASE WHEN $3::text = 'totalLikes' AND $4::text = 'ASC' THEN pl.total_likes END,
                    CASE WHEN $3::text = 'totalLikes' AND $4::text = 'DESC' THEN pl.total_likes END DESC,
                    p.id
                    ) AS row_num
         FROM "post" p
                  INNER JOIN "user" u ON p.user_id = u.id
                  INNER JOIN "artwork" a ON p.id = a.post_id
                  LEFT JOIN "artwork_price" ap ON a.id = ap.artwork_id AND ap.to_date IS NULL
                  LEFT JOIN post_likes pl ON p.id = pl.id
         WHERE
             (u.username ILIKE '%' || $6::text || '%')
           AND (($7::uuid[] IS NULL) OR (p.id IN (
             SELECT pt.post_id
             FROM "post_tags" pt
             WHERE pt.tag_id = ANY($7::uuid[])
         ))) AND a.is_buyable = $8::boolean
           AND p.is_ban = false
           AND p.is_deleted = false
           AND a.is_deleted = false
     ),
     total_count AS (
         SELECT COUNT(*) AS count FROM filtered_posts
     )
SELECT
    json_build_object(
            'items', json_agg(filtered_posts.* ),
            'totalCount', (SELECT count FROM total_count),
            'hasNextPage', (SELECT count FROM total_count) > ($1::INT * $2::INT),
            'hasPrevPage', $2 > 1,
            'totalPages', CEIL(CAST((SELECT count FROM total_count) AS FLOAT)/$1),
            'pageNumber', $2,
            'pageSize', $1,
            'sortBy', $3,
            'sortOrder', $4
    ) AS result
FROM
    filtered_posts
WHERE
    filtered_posts.row_num > (($2 - 1) * $1)
  AND filtered_posts.row_num <= ($2 * $1)
`

type GetPostsByUserAndTagsParams struct {
	Size       int32       `json:"size"`
	Page       int32       `json:"page"`
	SortBy     interface{} `json:"sortBy"`
	SortOrder  interface{} `json:"sortOrder"`
	UserID     interface{} `json:"userId"`
	SearchTerm string      `json:"searchTerm"`
	TagIds     []uuid.UUID `json:"tagIds"`
	IsBuyable  bool        `json:"isBuyable"`
}

func (q *Queries) GetPostsByUserAndTags(ctx context.Context, arg GetPostsByUserAndTagsParams) (json.RawMessage, error) {
	row := q.db.QueryRow(ctx, getPostsByUserAndTags,
		arg.Size,
		arg.Page,
		arg.SortBy,
		arg.SortOrder,
		arg.UserID,
		arg.SearchTerm,
		arg.TagIds,
		arg.IsBuyable,
	)
	var result json.RawMessage
	err := row.Scan(&result)
	return result, err
}
