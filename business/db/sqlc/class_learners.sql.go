// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: class_learners.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const addLearnerToClass = `-- name: AddLearnerToClass :exec
INSERT INTO class_learners (id, class_id, learner_id)
VALUES ($1::uuid, $2::uuid, $3)
`

type AddLearnerToClassParams struct {
	ID        uuid.UUID `db:"id" json:"id"`
	ClassID   uuid.UUID `db:"class_id" json:"classId"`
	LearnerID string    `db:"learner_id" json:"learnerId"`
}

func (q *Queries) AddLearnerToClass(ctx context.Context, arg AddLearnerToClassParams) error {
	_, err := q.db.Exec(ctx, addLearnerToClass, arg.ID, arg.ClassID, arg.LearnerID)
	return err
}

const addLearnersToClass = `-- name: AddLearnersToClass :many
INSERT INTO class_learners (id, class_id, learner_id)
VALUES (uuid_generate_v4(), $1::uuid, unnest($2::text[]))
RETURNING id::uuid AS ids
`

type AddLearnersToClassParams struct {
	ClassID    uuid.UUID `db:"class_id" json:"classId"`
	LearnerIds []string  `db:"learner_ids" json:"learnerIds"`
}

func (q *Queries) AddLearnersToClass(ctx context.Context, arg AddLearnersToClassParams) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, addLearnersToClass, arg.ClassID, arg.LearnerIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var ids uuid.UUID
		if err := rows.Scan(&ids); err != nil {
			return nil, err
		}
		items = append(items, ids)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const checkLearnerTimeOverlap = `-- name: CheckLearnerTimeOverlap :one
SELECT EXISTS (
    SELECT 1
    FROM
        users u
            JOIN class_learners cl ON cl.learner_id = u.id
            JOIN slots s ON s.class_id = cl.class_id
    WHERE cl.learner_id = $1
      AND s.start_time < $2
      AND s.end_time > $3
)
`

type CheckLearnerTimeOverlapParams struct {
	LearnerID string     `db:"learner_id" json:"learnerId"`
	EndTime   *time.Time `db:"end_time" json:"endTime"`
	StartTime *time.Time `db:"start_time" json:"startTime"`
}

func (q *Queries) CheckLearnerTimeOverlap(ctx context.Context, arg CheckLearnerTimeOverlapParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkLearnerTimeOverlap, arg.LearnerID, arg.EndTime, arg.StartTime)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkLearnersInClass = `-- name: CheckLearnersInClass :one
SELECT STRING_AGG(email, ', ') AS emails
FROM (
         SELECT u.email
         FROM users u
                  JOIN class_learners cl ON cl.learner_id = u.id
                  JOIN classes c ON cl.class_id = c.id
         WHERE cl.learner_id = ANY($1::text[])
         AND c.id = $2::uuid
         GROUP BY cl.learner_id, u.email
     ) as ucse
`

type CheckLearnersInClassParams struct {
	LearnerIds []string  `db:"learner_ids" json:"learnerIds"`
	ClassID    uuid.UUID `db:"class_id" json:"classId"`
}

func (q *Queries) CheckLearnersInClass(ctx context.Context, arg CheckLearnersInClassParams) ([]byte, error) {
	row := q.db.QueryRow(ctx, checkLearnersInClass, arg.LearnerIds, arg.ClassID)
	var emails []byte
	err := row.Scan(&emails)
	return emails, err
}

const countLearnersByClassId = `-- name: CountLearnersByClassId :one
SELECT COUNT(*) FROM class_learners WHERE class_id = $1::uuid
`

func (q *Queries) CountLearnersByClassId(ctx context.Context, classID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countLearnersByClassId, classID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getClassLearnerByClassAndLearner = `-- name: GetClassLearnerByClassAndLearner :one
SELECT id, learner_id, class_id FROM class_learners
         WHERE class_id = $1::uuid
           AND learner_id = $2
`

type GetClassLearnerByClassAndLearnerParams struct {
	ClassID   uuid.UUID `db:"class_id" json:"classId"`
	LearnerID string    `db:"learner_id" json:"learnerId"`
}

func (q *Queries) GetClassLearnerByClassAndLearner(ctx context.Context, arg GetClassLearnerByClassAndLearnerParams) (ClassLearner, error) {
	row := q.db.QueryRow(ctx, getClassLearnerByClassAndLearner, arg.ClassID, arg.LearnerID)
	var i ClassLearner
	err := row.Scan(&i.ID, &i.LearnerID, &i.ClassID)
	return i, err
}

const getClassesByLearnerId = `-- name: GetClassesByLearnerId :many
SELECT id, code, subject_id, program_id, password, name, link, start_date, end_date, status, type, created_by, created_at, updated_at, updated_by FROM classes
WHERE id IN (SELECT class_id FROM class_learners WHERE learner_id = $1)
`

func (q *Queries) GetClassesByLearnerId(ctx context.Context, learnerID string) ([]Class, error) {
	rows, err := q.db.Query(ctx, getClassesByLearnerId, learnerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Class
	for rows.Next() {
		var i Class
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.SubjectID,
			&i.ProgramID,
			&i.Password,
			&i.Name,
			&i.Link,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.Type,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLearnersByClassId = `-- name: GetLearnersByClassId :many
SELECT u.id, u.full_name, u.email, u.phone, u.profile_photo, u.status, u.type,
       cl.id AS class_learner_id, s.id AS school_id, s.name AS school_name
FROM users u
        JOIN class_learners cl ON cl.learner_id = u.id
        JOIN classes c ON cl.class_id = c.id
        JOIN verification_learners vl ON u.id = vl.learner_id
        JOIN schools s ON s.id = vl.school_id
WHERE c.id = $1::uuid
`

type GetLearnersByClassIdRow struct {
	ID             string    `db:"id" json:"id"`
	FullName       *string   `db:"full_name" json:"fullName"`
	Email          string    `db:"email" json:"email"`
	Phone          *string   `db:"phone" json:"phone"`
	ProfilePhoto   *string   `db:"profile_photo" json:"profilePhoto"`
	Status         int32     `db:"status" json:"status"`
	Type           *int16    `db:"type" json:"type"`
	ClassLearnerID uuid.UUID `db:"class_learner_id" json:"classLearnerId"`
	SchoolID       uuid.UUID `db:"school_id" json:"schoolId"`
	SchoolName     string    `db:"school_name" json:"schoolName"`
}

func (q *Queries) GetLearnersByClassId(ctx context.Context, classID uuid.UUID) ([]GetLearnersByClassIdRow, error) {
	rows, err := q.db.Query(ctx, getLearnersByClassId, classID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLearnersByClassIdRow
	for rows.Next() {
		var i GetLearnersByClassIdRow
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.Email,
			&i.Phone,
			&i.ProfilePhoto,
			&i.Status,
			&i.Type,
			&i.ClassLearnerID,
			&i.SchoolID,
			&i.SchoolName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLearnersTimeOverlap = `-- name: GetLearnersTimeOverlap :one
SELECT STRING_AGG(email, ', ') AS emails
FROM (
    SELECT u.email
        FROM users u
            JOIN class_learners cl ON cl.learner_id = u.id
            JOIN slots s ON s.class_id = cl.class_id
      WHERE u.email = ANY($1::text[])
        AND s.start_time < $2
        AND s.end_time > $3
      GROUP BY cl.learner_id, u.email
          ) as ucse
`

type GetLearnersTimeOverlapParams struct {
	Emails    []string   `db:"emails" json:"emails"`
	EndTime   *time.Time `db:"end_time" json:"endTime"`
	StartTime *time.Time `db:"start_time" json:"startTime"`
}

func (q *Queries) GetLearnersTimeOverlap(ctx context.Context, arg GetLearnersTimeOverlapParams) ([]byte, error) {
	row := q.db.QueryRow(ctx, getLearnersTimeOverlap, arg.Emails, arg.EndTime, arg.StartTime)
	var emails []byte
	err := row.Scan(&emails)
	return emails, err
}

const removeLearnerFromClass = `-- name: RemoveLearnerFromClass :exec
DELETE FROM class_learners
WHERE class_id = $1::uuid
  AND learner_id = $2
`

type RemoveLearnerFromClassParams struct {
	ClassID   uuid.UUID `db:"class_id" json:"classId"`
	LearnerID string    `db:"learner_id" json:"learnerId"`
}

func (q *Queries) RemoveLearnerFromClass(ctx context.Context, arg RemoveLearnerFromClassParams) error {
	_, err := q.db.Exec(ctx, removeLearnerFromClass, arg.ClassID, arg.LearnerID)
	return err
}
